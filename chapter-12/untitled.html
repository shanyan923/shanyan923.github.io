<!DOCTYPE html>
<html>
<head>
    <title>10.05 dynamic envmap</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <script src="../libs/three.js"></script>
    <script src="../libs/dat.gui.js"></script>
    <script src="../libs/OrbitControls.js"></script>
    <script type="text/javascript" src="../libs/jquery-1.9.0.js"></script>
    <script type="text/javascript" src="../libs/jquery-1.7.2.min.js"></script>

    <audio id="soundtrack" autoplay loop style="display:none">
    <source src="../assets/audio/jazz.ogg" type='audio/ogg'>
    </audio>

    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #sound{
            width: 80px;
            height:40px;
            background: white;
            z-index: 10000;
            float: right;
            position: absolute;
            font-size: 15px;
            }
        #sound:hover{
            background:skyblue;
        }

    </style>
</head>
<body>
<button id="sound">Mute</button>

<script>

    var controls, camera, scene, renderer;
    var cameraCube, sceneCube;
    var textureEquirec, textureCube;
    var cubeMesh;
    var equirectShader;

    
    init();
    animate();

    function init() {
    // CAMERAS
                camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 100000 );
                camera.position.set( 0, 0, 1000 );
                cameraCube = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 100000 );
                controls = new THREE.OrbitControls( camera );
                controls.minDistance = 500;
                controls.maxDistance = 2500;

    // SCENE
                scene = new THREE.Scene();
                sceneCube = new THREE.Scene();
                
    // Lights
                var ambient = new THREE.AmbientLight( 0xffffff );
                scene.add( ambient );

    // Textures
                var r = "../assets/textures/cubemap/parliament/";
                var format = '.jpg';
                var urls = [ 
                           r + 'right' + format, r + 'left' + format,
                           r + 'top' + format, r + 'bottom' + format,
                           r + 'back' + format, r + 'front' + format ];
                
                textureCube = THREE.ImageUtils.loadTextureCube( urls );
                textureCube.format = THREE.RGBFormat;
                textureCube.mapping = THREE.CubeReflectionMapping;

                var r = "../assets/textures/cubemap/parliament/";
                var format = '.jpg';
                var urls = [ 
                           r + 'posx' + format, r + 'negx' + format,
                           r + 'posy' + format, r + 'negy' + format,
                           r + 'posz' + format, r + 'negz' + format ];
                
                textureEquirec = THREE.ImageUtils.loadTextureCube( urls );
                textureEquirec.format = THREE.RGBFormat;
                textureEquirec.mapping = THREE.CubeReflectionMapping;




                /*var textureLoader = new THREE.TextureLoader();
                
                textureEquirec = textureLoader.load( "../assets/textures/cubemap/banquet.jpg" );
                textureEquirec.mapping = THREE.CubeReflectionMapping;
                textureEquirec.magFilter = THREE.LinearFilter;
                textureEquirec.minFilter = THREE.LinearMipMapLinearFilter;*/

    // Materials
                var equirectShader = THREE.ShaderLib[ "equirect" ];
                var equirectMaterial = new THREE.ShaderMaterial( {
                    fragmentShader: equirectShader.fragmentShader,
                    vertexShader: equirectShader.vertexShader,
                    uniforms: equirectShader.uniforms,
                    depthWrite: false,
                    side: THREE.BackSide
                } );
                equirectMaterial.uniforms[ "tEquirect" ].value = textureEquirec;
                
                var cubeShader = THREE.ShaderLib[ "cube" ];
                var cubeMaterial = new THREE.ShaderMaterial( {
                    fragmentShader: cubeShader.fragmentShader,
                    vertexShader: cubeShader.vertexShader,
                    uniforms: cubeShader.uniforms,
                    depthWrite: false,
                    side: THREE.BackSide
                } );
                cubeMaterial.uniforms[ "tCube" ].value = textureCube;
  // SKYBOX

                cubeMesh = new THREE.Mesh( new THREE.BoxGeometry( 100, 100, 100 ), cubeMaterial );
                sceneCube.add( cubeMesh );

 // Renderer

                renderer = new THREE.WebGLRenderer();
                //renderer.autoClear = false;
                //renderer.setPixelRatio( window.devicePixelRatio );
                //renderer.setSize( window.innerWidth, window.innerHeight );
                //renderer.setFaceCulling( THREE.CullFaceNone );
                document.body.appendChild( renderer.domElement );
// Switch Function
                
                var params = {
                    Cube: function () {
                        cubeMesh.material = cubeMaterial;
                        cubeMesh.visible = true;
                        
                    },
                    Equirectangular: function () {
                        cubeMesh.material = equirectMaterial;
                        cubeMesh.visible = true;
                        
                    },
                };
                
                var gui = new dat.GUI();
                gui.add( params, 'Cube' );
                gui.add( params, 'Equirectangular' );

                gui.open();
        }

        function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                cameraCube.aspect = window.innerWidth / window.innerHeight;
                cameraCube.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }

        function animate() {
                requestAnimationFrame( animate );
                render();
                controls.update();
            }

        function render() {
                var timer = -0.0002 * Date.now();
                camera.lookAt( scene.position );
                cameraCube.rotation.copy( camera.rotation );
                renderer.render( sceneCube, cameraCube );
                renderer.render( scene, camera );
            }

    

</script>
<body>
</body>
</html>